{"ast":null,"code":"var __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { getter } from '@progress/kendo-react-common';\n/** @hidden */\nexport var getValueMap = function (value, idGetter) {\n  var map = {};\n  if (value && value.length) {\n    value.forEach(function (item) {\n      map[idGetter(item)] = true;\n    });\n  }\n  return map;\n};\n/**\n * Get MultiSelectTree new value from the component `onChange` event.\n *\n * @param {any[]} data\n * @param {object} options\n * @returns {any[]}\n */\nexport var getMultiSelectTreeValue = function (data, options) {\n  var items = options.items,\n    dataItemKey = options.dataItemKey,\n    value = options.value,\n    _a = options.subItemsField,\n    subItemsField = _a === void 0 ? 'items' : _a,\n    operation = options.operation;\n  var idGetter = getter(dataItemKey);\n  var valueMap = getValueMap(value, idGetter);\n  if (operation === 'clear') {\n    return [];\n  } else if (operation === 'delete') {\n    var deletedItemsMap_1 = getValueMap(items, idGetter);\n    return value.filter(function (item) {\n      return !deletedItemsMap_1[idGetter(item)];\n    });\n  }\n  // operation === 'toggle'\n  var selectedItem = items[0];\n  var selectedId = idGetter(selectedItem);\n  var subItemGetter = getter(subItemsField);\n  var stack = __spreadArray([], data, true);\n  var context = [];\n  var parents = [];\n  var foundItem;\n  while (stack.length) {\n    var currentItem = stack.pop();\n    if (selectedId === idGetter(currentItem)) {\n      parents = context.map(function (contextItem) {\n        return contextItem.item;\n      });\n      foundItem = currentItem;\n      break;\n    } else {\n      if (context && context.length && context[context.length - 1].parentPosition === stack.length) {\n        context.pop();\n      }\n      var subItems = subItemGetter(currentItem);\n      if (subItems && subItems.length) {\n        context.push({\n          item: currentItem,\n          parentPosition: stack.length\n        });\n        stack.push.apply(stack, subItems);\n      }\n    }\n  }\n  var childrenStack = __spreadArray([], subItemGetter(foundItem) || [], true);\n  var children = [];\n  while (childrenStack.length) {\n    var currentItem = childrenStack.pop();\n    children.push(currentItem);\n    var subItems = subItemGetter(currentItem);\n    if (subItems && subItems.length) {\n      childrenStack.push.apply(childrenStack, subItems);\n    }\n  }\n  var isChecked = !valueMap[selectedId];\n  var newValue = [];\n  if (isChecked) {\n    newValue.push.apply(newValue, value);\n    newValue.push(foundItem);\n    newValue.push.apply(newValue, children.filter(function (item) {\n      return !valueMap[idGetter(item)];\n    }));\n    var parentCandidates = parents.filter(function (item) {\n      return !valueMap[idGetter(item)];\n    });\n    var newValueMap_1 = getValueMap(newValue, idGetter);\n    for (var i = parentCandidates.length - 1; i > -1; i--) {\n      var candidate = parentCandidates[i];\n      var subItems = subItemGetter(candidate);\n      var checkedChildrenLength = subItems.filter(function (item) {\n        return newValueMap_1[idGetter(item)];\n      }).length;\n      if (checkedChildrenLength < subItems.length) {\n        break;\n      } else {\n        newValue.push(candidate);\n        newValueMap_1[idGetter(candidate)] = true;\n      }\n    }\n  } else {\n    var foundId_1 = idGetter(foundItem);\n    var childrenMap_1 = getValueMap(children, idGetter);\n    var parentsMap_1 = getValueMap(parents, idGetter);\n    newValue.push.apply(newValue, value.filter(function (item) {\n      var itemId = idGetter(item);\n      return !childrenMap_1[itemId] && foundId_1 !== itemId && !parentsMap_1[itemId];\n    }));\n  }\n  return newValue;\n};\n// /** @hidden */\n// const mapCheckAndIntermidiate = (\n//     data,\n//     options: {\n//         valueMap: {[dataItemKey: string]: boolean};\n//         callback?: (item: any) => any;\n//         idGetter: (item: any) => any;\n//         subItemGetter: (item: any) => any;\n//         subItemSetter: (item: any, value: any) => void;\n//         checkSetter: (item: any, value: any) => void;\n//         checkIndeterminateSetter: (item: any, value: any) => void;\n//     }\n// ) => {\n//     const {\n//         idGetter,\n//         subItemGetter,\n//         subItemSetter,\n//         checkSetter,\n//         checkIndeterminateSetter\n//     } = options;\n//     if (!data || !data.length) { return [data, false];}\n//     let hasChecked = false;\n//     const newData = [...data].map(dataItem => {\n//         const [children, hasCheckedChildren] = mapCheckAndIntermidiate(subItemGetter(dataItem), options);\n//         const isChecked = options.valueMap[idGetter(dataItem)];\n//         if (isChecked || hasCheckedChildren) {\n//             hasChecked = true;\n//         }\n//         const newItem = { ...dataItem };\n//         subItemSetter(newItem, children);\n//         checkSetter(newItem, isChecked);\n//         checkIndeterminateSetter(newItem, !isChecked && hasCheckedChildren);\n//         return options.callback ? options.callback(newItem) : newItem;\n//     });\n//     return [newData, hasChecked];\n// };\n// /**\n//  *\n//  * @param data\n//  * @param options\n//  * @returns\n//  */\n// /**\n//  * Creates a new array with the results of calling the provided callback function\n//  * on every element in the provided data tree. The new tree items have their `check` and `checkIndeterminate` fields set based on provided value.\n//  *\n//  * @param {any[]} tree - The data tree.\n//  * @param {object} options - The options used to map the tree items like check and checkIndeterminateField fields\n//  * @returns {any[]} - The new data tree.\n//  */\n// export const mapMultiSelectTreeData = (\n//     tree,\n//     options: {\n//         checkField?: string;\n//         checkIndeterminateField?: string;\n//         subItemsField?: string;\n//         dataItemKey: string;\n//         value: Array<any>;\n//         callback?: (item) => any;\n//     }\n// ) => {\n//     const {\n//         subItemsField = 'items',\n//         checkField = 'checkField',\n//         checkIndeterminateField = 'checkIndeterminateField',\n//         callback\n//     } = options;\n//     const idGetter = getter(options.dataItemKey);\n//     const [result] = mapCheckAndIntermidiate(\n//         tree,\n//         {\n//             callback,\n//             valueMap: getValueMap(options.value, idGetter),\n//             idGetter,\n//             subItemGetter: getter(subItemsField),\n//             subItemSetter: setter(subItemsField),\n//             checkSetter: setter(checkField),\n//             checkIndeterminateSetter: setter(checkIndeterminateField)\n//         }\n//     );\n//     return result;\n// };","map":{"version":3,"names":["__spreadArray","to","from","pack","arguments","length","i","l","ar","Array","prototype","slice","call","concat","getter","getValueMap","value","idGetter","map","forEach","item","getMultiSelectTreeValue","data","options","items","dataItemKey","_a","subItemsField","operation","valueMap","deletedItemsMap_1","filter","selectedItem","selectedId","subItemGetter","stack","context","parents","foundItem","currentItem","pop","contextItem","parentPosition","subItems","push","apply","childrenStack","children","isChecked","newValue","parentCandidates","newValueMap_1","candidate","checkedChildrenLength","foundId_1","childrenMap_1","parentsMap_1","itemId"],"sources":["/Users/stanimiryakimov/Development/Kendo-Examples/kendo-drawer/node_modules/@progress/kendo-react-dropdowns/dist/es/MultiSelectTree/utils.js"],"sourcesContent":["var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { getter } from '@progress/kendo-react-common';\n/** @hidden */\nexport var getValueMap = function (value, idGetter) {\n    var map = {};\n    if (value && value.length) {\n        value.forEach(function (item) {\n            map[idGetter(item)] = true;\n        });\n    }\n    return map;\n};\n/**\n * Get MultiSelectTree new value from the component `onChange` event.\n *\n * @param {any[]} data\n * @param {object} options\n * @returns {any[]}\n */\nexport var getMultiSelectTreeValue = function (data, options) {\n    var items = options.items, dataItemKey = options.dataItemKey, value = options.value, _a = options.subItemsField, subItemsField = _a === void 0 ? 'items' : _a, operation = options.operation;\n    var idGetter = getter(dataItemKey);\n    var valueMap = getValueMap(value, idGetter);\n    if (operation === 'clear') {\n        return [];\n    }\n    else if (operation === 'delete') {\n        var deletedItemsMap_1 = getValueMap(items, idGetter);\n        return value.filter(function (item) { return !deletedItemsMap_1[idGetter(item)]; });\n    }\n    // operation === 'toggle'\n    var selectedItem = items[0];\n    var selectedId = idGetter(selectedItem);\n    var subItemGetter = getter(subItemsField);\n    var stack = __spreadArray([], data, true);\n    var context = [];\n    var parents = [];\n    var foundItem;\n    while (stack.length) {\n        var currentItem = stack.pop();\n        if (selectedId === idGetter(currentItem)) {\n            parents = context.map(function (contextItem) { return contextItem.item; });\n            foundItem = currentItem;\n            break;\n        }\n        else {\n            if (context &&\n                context.length &&\n                context[context.length - 1].parentPosition === stack.length) {\n                context.pop();\n            }\n            var subItems = subItemGetter(currentItem);\n            if (subItems && subItems.length) {\n                context.push({ item: currentItem, parentPosition: stack.length });\n                stack.push.apply(stack, subItems);\n            }\n        }\n    }\n    var childrenStack = __spreadArray([], (subItemGetter(foundItem) || []), true);\n    var children = [];\n    while (childrenStack.length) {\n        var currentItem = childrenStack.pop();\n        children.push(currentItem);\n        var subItems = subItemGetter(currentItem);\n        if (subItems && subItems.length) {\n            childrenStack.push.apply(childrenStack, subItems);\n        }\n    }\n    var isChecked = !valueMap[selectedId];\n    var newValue = [];\n    if (isChecked) {\n        newValue.push.apply(newValue, value);\n        newValue.push(foundItem);\n        newValue.push.apply(newValue, children.filter(function (item) { return !valueMap[idGetter(item)]; }));\n        var parentCandidates = parents.filter(function (item) { return !valueMap[idGetter(item)]; });\n        var newValueMap_1 = getValueMap(newValue, idGetter);\n        for (var i = parentCandidates.length - 1; i > -1; i--) {\n            var candidate = parentCandidates[i];\n            var subItems = subItemGetter(candidate);\n            var checkedChildrenLength = subItems.filter(function (item) { return newValueMap_1[idGetter(item)]; }).length;\n            if (checkedChildrenLength < subItems.length) {\n                break;\n            }\n            else {\n                newValue.push(candidate);\n                newValueMap_1[idGetter(candidate)] = true;\n            }\n        }\n    }\n    else {\n        var foundId_1 = idGetter(foundItem);\n        var childrenMap_1 = getValueMap(children, idGetter);\n        var parentsMap_1 = getValueMap(parents, idGetter);\n        newValue.push.apply(newValue, (value\n            .filter(function (item) {\n            var itemId = idGetter(item);\n            return !childrenMap_1[itemId] && foundId_1 !== itemId && !parentsMap_1[itemId];\n        })));\n    }\n    return newValue;\n};\n// /** @hidden */\n// const mapCheckAndIntermidiate = (\n//     data,\n//     options: {\n//         valueMap: {[dataItemKey: string]: boolean};\n//         callback?: (item: any) => any;\n//         idGetter: (item: any) => any;\n//         subItemGetter: (item: any) => any;\n//         subItemSetter: (item: any, value: any) => void;\n//         checkSetter: (item: any, value: any) => void;\n//         checkIndeterminateSetter: (item: any, value: any) => void;\n//     }\n// ) => {\n//     const {\n//         idGetter,\n//         subItemGetter,\n//         subItemSetter,\n//         checkSetter,\n//         checkIndeterminateSetter\n//     } = options;\n//     if (!data || !data.length) { return [data, false];}\n//     let hasChecked = false;\n//     const newData = [...data].map(dataItem => {\n//         const [children, hasCheckedChildren] = mapCheckAndIntermidiate(subItemGetter(dataItem), options);\n//         const isChecked = options.valueMap[idGetter(dataItem)];\n//         if (isChecked || hasCheckedChildren) {\n//             hasChecked = true;\n//         }\n//         const newItem = { ...dataItem };\n//         subItemSetter(newItem, children);\n//         checkSetter(newItem, isChecked);\n//         checkIndeterminateSetter(newItem, !isChecked && hasCheckedChildren);\n//         return options.callback ? options.callback(newItem) : newItem;\n//     });\n//     return [newData, hasChecked];\n// };\n// /**\n//  *\n//  * @param data\n//  * @param options\n//  * @returns\n//  */\n// /**\n//  * Creates a new array with the results of calling the provided callback function\n//  * on every element in the provided data tree. The new tree items have their `check` and `checkIndeterminate` fields set based on provided value.\n//  *\n//  * @param {any[]} tree - The data tree.\n//  * @param {object} options - The options used to map the tree items like check and checkIndeterminateField fields\n//  * @returns {any[]} - The new data tree.\n//  */\n// export const mapMultiSelectTreeData = (\n//     tree,\n//     options: {\n//         checkField?: string;\n//         checkIndeterminateField?: string;\n//         subItemsField?: string;\n//         dataItemKey: string;\n//         value: Array<any>;\n//         callback?: (item) => any;\n//     }\n// ) => {\n//     const {\n//         subItemsField = 'items',\n//         checkField = 'checkField',\n//         checkIndeterminateField = 'checkIndeterminateField',\n//         callback\n//     } = options;\n//     const idGetter = getter(options.dataItemKey);\n//     const [result] = mapCheckAndIntermidiate(\n//         tree,\n//         {\n//             callback,\n//             valueMap: getValueMap(options.value, idGetter),\n//             idGetter,\n//             subItemGetter: getter(subItemsField),\n//             subItemSetter: setter(subItemsField),\n//             checkSetter: setter(checkField),\n//             checkIndeterminateSetter: setter(checkIndeterminateField)\n//         }\n//     );\n//     return result;\n// };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}