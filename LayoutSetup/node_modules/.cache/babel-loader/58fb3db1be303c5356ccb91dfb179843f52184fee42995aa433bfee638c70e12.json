{"ast":null,"code":"import { DOM_KENDO_ITEM_ID_FIELD, DOM_KENDO_TREEVIEW_GUID_FIELD } from './utils/consts';\nvar DROPZONE_BOUNDARY_DELTA = 6;\n/**\n * A class which provides an API for analyzing the `drag` events\n * of the TreeView.\n *\n * @example\n * ```jsx\n * class App extends React.Component {\n *     dragClue;\n *     state = { tree };\n *\n *     render() {\n *         return (\n *             <div>\n *                 <TreeView data={this.state.tree} draggable={true}\n *                     onItemDragOver={this.onItemDragOver} onItemDragEnd={this.onItemDragEnd} />\n *                 <TreeViewDragClue ref={dragClue => this.dragClue = dragClue} />\n *             </div>\n *         );\n *     }\n *\n *     onItemDragOver = (event) => {\n *         this.dragClue.show(event.pageY + 10, event.pageX, event.item.text, this.getClueClassName(event));\n *     }\n *     onItemDragEnd = (event) => {\n *         this.dragClue.hide();\n *         const eventAnalyzer = new TreeViewDragAnalyzer(event).init();\n *\n *         if (eventAnalyzer.isDropAllowed) {\n *             const updatedTree = moveTreeViewItem(\n *                 event.itemHierarchicalIndex,\n *                 this.state.tree,\n *                 eventAnalyzer.getDropOperation(),\n *                 eventAnalyzer.destinationMeta.itemHierarchicalIndex,\n *             );\n *\n *             this.setState({ tree: updatedTree });\n *         }\n *     }\n *     getClueClassName(event) {\n *         const eventAnalyzer = new TreeViewDragAnalyzer(event).init();\n *         const itemIndex = eventAnalyzer.destinationMeta.itemHierarchicalIndex;\n *\n *         if (eventAnalyzer.isDropAllowed) {\n *             switch (eventAnalyzer.getDropOperation()) {\n *                 case 'child':\n *                     return 'k-i-plus';\n *                 case 'before':\n *                     return itemIndex === '0' || itemIndex.endsWith(`${SEPARATOR}0`) ?\n *                         'k-i-insert-up' : 'k-i-insert-middle';\n *                 case 'after':\n *                     const siblings = getSiblings(itemIndex, this.state.tree);\n *                     const lastIndex = Number(itemIndex.split(SEPARATOR).pop());\n *\n *                     return lastIndex < siblings.length - 1 ? 'k-i-insert-middle' : 'k-i-insert-down';\n *                 default:\n *                     break;\n *             }\n *         }\n *\n *         return 'k-i-cancel';\n *     }\n * }\n *\n * function getSiblings(itemIndex, data) {\n *     let result = data;\n *\n *     const indices = itemIndex.split(SEPARATOR).map(index => Number(index));\n *     for (let i = 0; i < indices.length - 1; i++) {\n *         result = result[indices[i]].items;\n *     }\n *\n *     return result;\n * }\n *\n * const SEPARATOR = '_';\n * const tree = [{\n *     text: 'Furniture', expanded: true, items: [\n *         { text: 'Tables & Chairs', expanded: true },\n *         { text: 'Sofas', expanded: true },\n *         { text: 'Occasional Furniture', expanded: true }]\n * }, {\n *     text: 'Decor', expanded: true, items: [\n *         { text: 'Bed Linen', expanded: true },\n *         { text: 'Curtains & Blinds', expanded: true },\n *         { text: 'Carpets', expanded: true }]\n * }];\n *\n * ReactDOM.render(<App />, document.querySelector('my-app'));\n * ```\n */\nvar TreeViewDragAnalyzer = /** @class */function () {\n  /**\n   * @param event - The event that will be analyzed.\n   */\n  function TreeViewDragAnalyzer(event) {\n    this.event = event;\n    this.initialized = false;\n    this.destItemId = '';\n    this.destTreeViewGuid = '';\n    this.itemId = event.itemHierarchicalIndex;\n    this.treeViewGuid = event.target.guid;\n  }\n  /**\n   * The method which initializes the analyzer.\n   * Invoke the method before you call any other methods.\n   *\n   * @returns - The analyzer object of the `drag` event.\n   */\n  TreeViewDragAnalyzer.prototype.init = function () {\n    if (!this.initialized) {\n      this.setDestimationMeta(document.elementFromPoint(this.event.clientX, this.event.clientY));\n      this.initialized = true;\n    }\n    return this;\n  };\n  Object.defineProperty(TreeViewDragAnalyzer.prototype, \"isDropAllowed\", {\n    /**\n     * Returns `true` if dropping is allowed. Otherwise, returns `false`.\n     */\n    get: function () {\n      if (this.initialized && this.destItemId && this.destTreeViewGuid) {\n        // Disallow circular references.\n        return !\"\".concat(this.destTreeViewGuid, \"_\").concat(this.destItemId, \"_\").startsWith(\"\".concat(this.treeViewGuid, \"_\").concat(this.itemId, \"_\"));\n      } else {\n        return false;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TreeViewDragAnalyzer.prototype, \"destinationMeta\", {\n    /**\n     * Returns an object which contains:\n     * * The `itemHierarchicalIndex` of the destination item (the item below the dragged item) and\n     * * The `guid` of the destination TreeView (the TreeView which renders the destination item).\n     */\n    get: function () {\n      return {\n        itemHierarchicalIndex: this.destItemId,\n        treeViewGuid: this.destTreeViewGuid\n      };\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Returns the specific drop operation.\n   *\n   * @returns - The following values are returned:\n   * * `before`&mdash;Indicates that the dragged item is positioned at the beginning of the destination item.\n   * * `after`&mdash;Indicates that the dragged item is positioned at the end of the destination item.\n   * * `child`&mdash;Indicates that the dragged item is positioned in the middle of the destination item.\n   * * `undefined`&mdash;Indicates that dropping is not allowed.\n   */\n  TreeViewDragAnalyzer.prototype.getDropOperation = function () {\n    if (this.initialized && this.isDropAllowed) {\n      var _a = this.destDomNodeWithMeta.getBoundingClientRect(),\n        top_1 = _a.top,\n        height = _a.height;\n      if (top_1 + height - this.event.clientY < DROPZONE_BOUNDARY_DELTA) {\n        return 'after';\n      } else if (this.event.clientY - top_1 < DROPZONE_BOUNDARY_DELTA) {\n        return 'before';\n      } else {\n        return 'child';\n      }\n    } else {\n      return undefined;\n    }\n  };\n  TreeViewDragAnalyzer.prototype.setDestimationMeta = function (element) {\n    var node = element;\n    while (node && !node[DOM_KENDO_ITEM_ID_FIELD]) {\n      node = node.parentNode;\n    }\n    if (node && node[DOM_KENDO_ITEM_ID_FIELD]) {\n      this.destDomNodeWithMeta = node;\n      this.destItemId = node[DOM_KENDO_ITEM_ID_FIELD];\n      this.destTreeViewGuid = node[DOM_KENDO_TREEVIEW_GUID_FIELD];\n    }\n  };\n  return TreeViewDragAnalyzer;\n}();\nexport { TreeViewDragAnalyzer };","map":{"version":3,"names":["DOM_KENDO_ITEM_ID_FIELD","DOM_KENDO_TREEVIEW_GUID_FIELD","DROPZONE_BOUNDARY_DELTA","TreeViewDragAnalyzer","event","initialized","destItemId","destTreeViewGuid","itemId","itemHierarchicalIndex","treeViewGuid","target","guid","prototype","init","setDestimationMeta","document","elementFromPoint","clientX","clientY","Object","defineProperty","get","concat","startsWith","enumerable","configurable","getDropOperation","isDropAllowed","_a","destDomNodeWithMeta","getBoundingClientRect","top_1","top","height","undefined","element","node","parentNode"],"sources":["/Users/stanimiryakimov/Development/Kendo-Examples/node_modules/@progress/kendo-react-treeview/dist/es/TreeViewDragAnalyzer.js"],"sourcesContent":["import { DOM_KENDO_ITEM_ID_FIELD, DOM_KENDO_TREEVIEW_GUID_FIELD } from './utils/consts';\nvar DROPZONE_BOUNDARY_DELTA = 6;\n/**\n * A class which provides an API for analyzing the `drag` events\n * of the TreeView.\n *\n * @example\n * ```jsx\n * class App extends React.Component {\n *     dragClue;\n *     state = { tree };\n *\n *     render() {\n *         return (\n *             <div>\n *                 <TreeView data={this.state.tree} draggable={true}\n *                     onItemDragOver={this.onItemDragOver} onItemDragEnd={this.onItemDragEnd} />\n *                 <TreeViewDragClue ref={dragClue => this.dragClue = dragClue} />\n *             </div>\n *         );\n *     }\n *\n *     onItemDragOver = (event) => {\n *         this.dragClue.show(event.pageY + 10, event.pageX, event.item.text, this.getClueClassName(event));\n *     }\n *     onItemDragEnd = (event) => {\n *         this.dragClue.hide();\n *         const eventAnalyzer = new TreeViewDragAnalyzer(event).init();\n *\n *         if (eventAnalyzer.isDropAllowed) {\n *             const updatedTree = moveTreeViewItem(\n *                 event.itemHierarchicalIndex,\n *                 this.state.tree,\n *                 eventAnalyzer.getDropOperation(),\n *                 eventAnalyzer.destinationMeta.itemHierarchicalIndex,\n *             );\n *\n *             this.setState({ tree: updatedTree });\n *         }\n *     }\n *     getClueClassName(event) {\n *         const eventAnalyzer = new TreeViewDragAnalyzer(event).init();\n *         const itemIndex = eventAnalyzer.destinationMeta.itemHierarchicalIndex;\n *\n *         if (eventAnalyzer.isDropAllowed) {\n *             switch (eventAnalyzer.getDropOperation()) {\n *                 case 'child':\n *                     return 'k-i-plus';\n *                 case 'before':\n *                     return itemIndex === '0' || itemIndex.endsWith(`${SEPARATOR}0`) ?\n *                         'k-i-insert-up' : 'k-i-insert-middle';\n *                 case 'after':\n *                     const siblings = getSiblings(itemIndex, this.state.tree);\n *                     const lastIndex = Number(itemIndex.split(SEPARATOR).pop());\n *\n *                     return lastIndex < siblings.length - 1 ? 'k-i-insert-middle' : 'k-i-insert-down';\n *                 default:\n *                     break;\n *             }\n *         }\n *\n *         return 'k-i-cancel';\n *     }\n * }\n *\n * function getSiblings(itemIndex, data) {\n *     let result = data;\n *\n *     const indices = itemIndex.split(SEPARATOR).map(index => Number(index));\n *     for (let i = 0; i < indices.length - 1; i++) {\n *         result = result[indices[i]].items;\n *     }\n *\n *     return result;\n * }\n *\n * const SEPARATOR = '_';\n * const tree = [{\n *     text: 'Furniture', expanded: true, items: [\n *         { text: 'Tables & Chairs', expanded: true },\n *         { text: 'Sofas', expanded: true },\n *         { text: 'Occasional Furniture', expanded: true }]\n * }, {\n *     text: 'Decor', expanded: true, items: [\n *         { text: 'Bed Linen', expanded: true },\n *         { text: 'Curtains & Blinds', expanded: true },\n *         { text: 'Carpets', expanded: true }]\n * }];\n *\n * ReactDOM.render(<App />, document.querySelector('my-app'));\n * ```\n */\nvar TreeViewDragAnalyzer = /** @class */ (function () {\n    /**\n     * @param event - The event that will be analyzed.\n     */\n    function TreeViewDragAnalyzer(event) {\n        this.event = event;\n        this.initialized = false;\n        this.destItemId = '';\n        this.destTreeViewGuid = '';\n        this.itemId = event.itemHierarchicalIndex;\n        this.treeViewGuid = event.target.guid;\n    }\n    /**\n     * The method which initializes the analyzer.\n     * Invoke the method before you call any other methods.\n     *\n     * @returns - The analyzer object of the `drag` event.\n     */\n    TreeViewDragAnalyzer.prototype.init = function () {\n        if (!this.initialized) {\n            this.setDestimationMeta(document.elementFromPoint(this.event.clientX, this.event.clientY));\n            this.initialized = true;\n        }\n        return this;\n    };\n    Object.defineProperty(TreeViewDragAnalyzer.prototype, \"isDropAllowed\", {\n        /**\n         * Returns `true` if dropping is allowed. Otherwise, returns `false`.\n         */\n        get: function () {\n            if (this.initialized && this.destItemId && this.destTreeViewGuid) {\n                // Disallow circular references.\n                return !((\"\".concat(this.destTreeViewGuid, \"_\").concat(this.destItemId, \"_\")).\n                    startsWith(\"\".concat(this.treeViewGuid, \"_\").concat(this.itemId, \"_\")));\n            }\n            else {\n                return false;\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TreeViewDragAnalyzer.prototype, \"destinationMeta\", {\n        /**\n         * Returns an object which contains:\n         * * The `itemHierarchicalIndex` of the destination item (the item below the dragged item) and\n         * * The `guid` of the destination TreeView (the TreeView which renders the destination item).\n         */\n        get: function () {\n            return { itemHierarchicalIndex: this.destItemId, treeViewGuid: this.destTreeViewGuid };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Returns the specific drop operation.\n     *\n     * @returns - The following values are returned:\n     * * `before`&mdash;Indicates that the dragged item is positioned at the beginning of the destination item.\n     * * `after`&mdash;Indicates that the dragged item is positioned at the end of the destination item.\n     * * `child`&mdash;Indicates that the dragged item is positioned in the middle of the destination item.\n     * * `undefined`&mdash;Indicates that dropping is not allowed.\n     */\n    TreeViewDragAnalyzer.prototype.getDropOperation = function () {\n        if (this.initialized && this.isDropAllowed) {\n            var _a = this.destDomNodeWithMeta.getBoundingClientRect(), top_1 = _a.top, height = _a.height;\n            if (top_1 + height - this.event.clientY < DROPZONE_BOUNDARY_DELTA) {\n                return 'after';\n            }\n            else if (this.event.clientY - top_1 < DROPZONE_BOUNDARY_DELTA) {\n                return 'before';\n            }\n            else {\n                return 'child';\n            }\n        }\n        else {\n            return undefined;\n        }\n    };\n    TreeViewDragAnalyzer.prototype.setDestimationMeta = function (element) {\n        var node = element;\n        while (node && !node[DOM_KENDO_ITEM_ID_FIELD]) {\n            node = node.parentNode;\n        }\n        if (node && node[DOM_KENDO_ITEM_ID_FIELD]) {\n            this.destDomNodeWithMeta = node;\n            this.destItemId = node[DOM_KENDO_ITEM_ID_FIELD];\n            this.destTreeViewGuid = node[DOM_KENDO_TREEVIEW_GUID_FIELD];\n        }\n    };\n    return TreeViewDragAnalyzer;\n}());\nexport { TreeViewDragAnalyzer };\n"],"mappings":"AAAA,SAASA,uBAAuB,EAAEC,6BAA6B,QAAQ,gBAAgB;AACvF,IAAIC,uBAAuB,GAAG,CAAC;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIC,oBAAoB,GAAG,aAAe,YAAY;EAClD;AACJ;AACA;EACI,SAASA,oBAAoBA,CAACC,KAAK,EAAE;IACjC,IAAI,CAACA,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACC,WAAW,GAAG,KAAK;IACxB,IAAI,CAACC,UAAU,GAAG,EAAE;IACpB,IAAI,CAACC,gBAAgB,GAAG,EAAE;IAC1B,IAAI,CAACC,MAAM,GAAGJ,KAAK,CAACK,qBAAqB;IACzC,IAAI,CAACC,YAAY,GAAGN,KAAK,CAACO,MAAM,CAACC,IAAI;EACzC;EACA;AACJ;AACA;AACA;AACA;AACA;EACIT,oBAAoB,CAACU,SAAS,CAACC,IAAI,GAAG,YAAY;IAC9C,IAAI,CAAC,IAAI,CAACT,WAAW,EAAE;MACnB,IAAI,CAACU,kBAAkB,CAACC,QAAQ,CAACC,gBAAgB,CAAC,IAAI,CAACb,KAAK,CAACc,OAAO,EAAE,IAAI,CAACd,KAAK,CAACe,OAAO,CAAC,CAAC;MAC1F,IAAI,CAACd,WAAW,GAAG,IAAI;IAC3B;IACA,OAAO,IAAI;EACf,CAAC;EACDe,MAAM,CAACC,cAAc,CAAClB,oBAAoB,CAACU,SAAS,EAAE,eAAe,EAAE;IACnE;AACR;AACA;IACQS,GAAG,EAAE,SAAAA,CAAA,EAAY;MACb,IAAI,IAAI,CAACjB,WAAW,IAAI,IAAI,CAACC,UAAU,IAAI,IAAI,CAACC,gBAAgB,EAAE;QAC9D;QACA,OAAO,CAAG,EAAE,CAACgB,MAAM,CAAC,IAAI,CAAChB,gBAAgB,EAAE,GAAG,CAAC,CAACgB,MAAM,CAAC,IAAI,CAACjB,UAAU,EAAE,GAAG,CAAC,CACxEkB,UAAU,CAAC,EAAE,CAACD,MAAM,CAAC,IAAI,CAACb,YAAY,EAAE,GAAG,CAAC,CAACa,MAAM,CAAC,IAAI,CAACf,MAAM,EAAE,GAAG,CAAC,CAAE;MAC/E,CAAC,MACI;QACD,OAAO,KAAK;MAChB;IACJ,CAAC;IACDiB,UAAU,EAAE,KAAK;IACjBC,YAAY,EAAE;EAClB,CAAC,CAAC;EACFN,MAAM,CAACC,cAAc,CAAClB,oBAAoB,CAACU,SAAS,EAAE,iBAAiB,EAAE;IACrE;AACR;AACA;AACA;AACA;IACQS,GAAG,EAAE,SAAAA,CAAA,EAAY;MACb,OAAO;QAAEb,qBAAqB,EAAE,IAAI,CAACH,UAAU;QAAEI,YAAY,EAAE,IAAI,CAACH;MAAiB,CAAC;IAC1F,CAAC;IACDkB,UAAU,EAAE,KAAK;IACjBC,YAAY,EAAE;EAClB,CAAC,CAAC;EACF;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIvB,oBAAoB,CAACU,SAAS,CAACc,gBAAgB,GAAG,YAAY;IAC1D,IAAI,IAAI,CAACtB,WAAW,IAAI,IAAI,CAACuB,aAAa,EAAE;MACxC,IAAIC,EAAE,GAAG,IAAI,CAACC,mBAAmB,CAACC,qBAAqB,EAAE;QAAEC,KAAK,GAAGH,EAAE,CAACI,GAAG;QAAEC,MAAM,GAAGL,EAAE,CAACK,MAAM;MAC7F,IAAIF,KAAK,GAAGE,MAAM,GAAG,IAAI,CAAC9B,KAAK,CAACe,OAAO,GAAGjB,uBAAuB,EAAE;QAC/D,OAAO,OAAO;MAClB,CAAC,MACI,IAAI,IAAI,CAACE,KAAK,CAACe,OAAO,GAAGa,KAAK,GAAG9B,uBAAuB,EAAE;QAC3D,OAAO,QAAQ;MACnB,CAAC,MACI;QACD,OAAO,OAAO;MAClB;IACJ,CAAC,MACI;MACD,OAAOiC,SAAS;IACpB;EACJ,CAAC;EACDhC,oBAAoB,CAACU,SAAS,CAACE,kBAAkB,GAAG,UAAUqB,OAAO,EAAE;IACnE,IAAIC,IAAI,GAAGD,OAAO;IAClB,OAAOC,IAAI,IAAI,CAACA,IAAI,CAACrC,uBAAuB,CAAC,EAAE;MAC3CqC,IAAI,GAAGA,IAAI,CAACC,UAAU;IAC1B;IACA,IAAID,IAAI,IAAIA,IAAI,CAACrC,uBAAuB,CAAC,EAAE;MACvC,IAAI,CAAC8B,mBAAmB,GAAGO,IAAI;MAC/B,IAAI,CAAC/B,UAAU,GAAG+B,IAAI,CAACrC,uBAAuB,CAAC;MAC/C,IAAI,CAACO,gBAAgB,GAAG8B,IAAI,CAACpC,6BAA6B,CAAC;IAC/D;EACJ,CAAC;EACD,OAAOE,oBAAoB;AAC/B,CAAC,EAAG;AACJ,SAASA,oBAAoB"},"metadata":{},"sourceType":"module","externalDependencies":[]}