{"ast":null,"code":"import { addItem, removeItem } from './utils/itemUtils';\nimport { getDecrementedItemIdAfterRemoval, getItemById } from './utils/itemIdUtils';\nimport { CHILDREN_FIELD } from './utils/consts';\n/**\n *  A helper function which moves a TreeView item in an immutable way.\n *\n * @param sourceItemHierarchicalIndex - The hierarchical index of the item that will be moved.\n * @param sourceData - The tree which contains the item that will be moved.\n * @param operation - The specific move operation.\n *\n * The available options are:\n *  * `before`&mdash;Indicates that the source item will become the previous sibling of the target item.\n *  * `after`&mdash;Indicates that the source item will become the next sibling of the target item.\n *  * `child`&mdash;Indicates that the source item will become a child of the target item.\n * @param targetItemHierarchicalIndex - The hierarchical index of the item next to which the source item will be moved.\n * @param targetData - The tree which contains the target item.\n * If the argument is skipped, then the move operation will be executed within the same tree.\n * Setting the `sourceData` and `targetData` arguments to the same tree is also supported.\n * @param childrenField - The field that points to the dataItem sub items. Defaults to `items`.\n * @returns - The updated copies of the `sourceData` and `targetData` input arguments.\n * If `targetData` is not passed, then only the updated copy of the `sourceData` will be returned.\n *\n * @example\n * ```jsx\n * class App extends React.Component {\n *     dragClue;\n *     state = { tree };\n *\n *     render() {\n *         return (\n *             <div>\n *                 <TreeView data={this.state.tree} draggable={true}\n *                     onItemDragOver={this.onItemDragOver} onItemDragEnd={this.onItemDragEnd} />\n *                 <TreeViewDragClue ref={dragClue => this.dragClue = dragClue} />\n *             </div>\n *         );\n *     }\n *\n *     onItemDragOver = (event) => {\n *         this.dragClue.show(event.pageY + 10, event.pageX, event.item.text, this.getClueClassName(event));\n *     }\n *     onItemDragEnd = (event) => {\n *         this.dragClue.hide();\n *         const eventAnalyzer = new TreeViewDragAnalyzer(event).init();\n *\n *         if (eventAnalyzer.isDropAllowed) {\n *             const updatedTree = moveTreeViewItem(\n *                 event.itemHierarchicalIndex,\n *                 this.state.tree,\n *                 eventAnalyzer.getDropOperation(),\n *                 eventAnalyzer.destinationMeta.itemHierarchicalIndex,\n *             );\n *\n *             this.setState({ tree: updatedTree });\n *         }\n *     }\n *     getClueClassName(event) {\n *         const eventAnalyzer = new TreeViewDragAnalyzer(event).init();\n *         const itemIndex = eventAnalyzer.destinationMeta.itemHierarchicalIndex;\n *\n *         if (eventAnalyzer.isDropAllowed) {\n *             switch (eventAnalyzer.getDropOperation()) {\n *                 case 'child':\n *                     return 'k-i-plus';\n *                 case 'before':\n *                     return itemIndex === '0' || itemIndex.endsWith(`${SEPARATOR}0`) ?\n *                         'k-i-insert-up' : 'k-i-insert-middle';\n *                 case 'after':\n *                     const siblings = getSiblings(itemIndex, this.state.tree);\n *                     const lastIndex = Number(itemIndex.split(SEPARATOR).pop());\n *\n *                     return lastIndex < siblings.length - 1 ? 'k-i-insert-middle' : 'k-i-insert-down';\n *                 default:\n *                     break;\n *             }\n *         }\n *\n *         return 'k-i-cancel';\n *     }\n * }\n *\n * function getSiblings(itemIndex, data) {\n *     let result = data;\n *\n *     const indices = itemIndex.split(SEPARATOR).map(index => Number(index));\n *     for (let i = 0; i < indices.length - 1; i++) {\n *         result = result[indices[i]].items;\n *     }\n *\n *     return result;\n * }\n *\n * const SEPARATOR = '_';\n * const tree = [{\n *     text: 'Furniture', expanded: true, items: [\n *         { text: 'Tables & Chairs', expanded: true },\n *         { text: 'Sofas', expanded: true },\n *         { text: 'Occasional Furniture', expanded: true }]\n * }, {\n *     text: 'Decor', expanded: true, items: [\n *         { text: 'Bed Linen', expanded: true },\n *         { text: 'Curtains & Blinds', expanded: true },\n *         { text: 'Carpets', expanded: true }]\n * }];\n *\n * ReactDOM.render(<App />, document.querySelector('my-app'));\n * ```\n */\nexport function moveTreeViewItem(sourceItemHierarchicalIndex, sourceData, operation, targetItemHierarchicalIndex, targetData, childrenField) {\n  var subItemsField = childrenField || CHILDREN_FIELD;\n  if (!validateInput()) {\n    return prepareInputDataForReturn();\n  }\n  var sourceItem = getItemById(sourceItemHierarchicalIndex, sourceData, subItemsField);\n  if (!sourceItem) {\n    return prepareInputDataForReturn();\n  }\n  // The source and the target tree are the same.\n  if (!targetData || targetData === sourceData) {\n    if (!validateNoCircularReference()) {\n      return prepareInputDataForReturn();\n    }\n    var updatedSourceData = removeItem(sourceItemHierarchicalIndex, subItemsField, sourceData);\n    var resultData = addItem(sourceItem, operation, subItemsField, getDecrementedItemIdAfterRemoval(sourceItemHierarchicalIndex, targetItemHierarchicalIndex), updatedSourceData);\n    // A simpler output is explicitly returned when the source and the target tree are\n    // the same, that is, the targetData argument is skipped.\n    return targetData ? {\n      sourceData: resultData,\n      targetData: resultData\n    } : resultData;\n  } else {\n    var updatedSource = removeItem(sourceItemHierarchicalIndex, subItemsField, sourceData);\n    var updatedTarget = addItem(sourceItem, operation, subItemsField, targetItemHierarchicalIndex, targetData);\n    return {\n      sourceData: updatedSource,\n      targetData: updatedTarget\n    };\n  }\n  function prepareInputDataForReturn() {\n    return targetData ? {\n      sourceData: sourceData,\n      targetData: targetData\n    } : sourceData;\n  }\n  function validateNoCircularReference() {\n    return !\"\".concat(targetItemHierarchicalIndex, \"_\").startsWith(\"\".concat(sourceItemHierarchicalIndex, \"_\"));\n  }\n  function validateInput() {\n    if (!sourceData || !sourceData.length || !sourceItemHierarchicalIndex || !targetItemHierarchicalIndex) {\n      return false;\n    }\n    if (targetData && !targetData.length) {\n      // Dropping over an empty tree is not supported.\n      return false;\n    }\n    // Validate that the target item exists.\n    var data = !targetData || targetData === sourceData ? sourceData : targetData;\n    if (!getItemById(targetItemHierarchicalIndex, data, subItemsField)) {\n      return false;\n    }\n    return true;\n  }\n}","map":{"version":3,"names":["addItem","removeItem","getDecrementedItemIdAfterRemoval","getItemById","CHILDREN_FIELD","moveTreeViewItem","sourceItemHierarchicalIndex","sourceData","operation","targetItemHierarchicalIndex","targetData","childrenField","subItemsField","validateInput","prepareInputDataForReturn","sourceItem","validateNoCircularReference","updatedSourceData","resultData","updatedSource","updatedTarget","concat","startsWith","length","data"],"sources":["/Users/stanimiryakimov/Development/Kendo-Examples/node_modules/@progress/kendo-react-treeview/dist/es/moveTreeViewItem.js"],"sourcesContent":["import { addItem, removeItem } from './utils/itemUtils';\nimport { getDecrementedItemIdAfterRemoval, getItemById } from './utils/itemIdUtils';\nimport { CHILDREN_FIELD } from './utils/consts';\n/**\n *  A helper function which moves a TreeView item in an immutable way.\n *\n * @param sourceItemHierarchicalIndex - The hierarchical index of the item that will be moved.\n * @param sourceData - The tree which contains the item that will be moved.\n * @param operation - The specific move operation.\n *\n * The available options are:\n *  * `before`&mdash;Indicates that the source item will become the previous sibling of the target item.\n *  * `after`&mdash;Indicates that the source item will become the next sibling of the target item.\n *  * `child`&mdash;Indicates that the source item will become a child of the target item.\n * @param targetItemHierarchicalIndex - The hierarchical index of the item next to which the source item will be moved.\n * @param targetData - The tree which contains the target item.\n * If the argument is skipped, then the move operation will be executed within the same tree.\n * Setting the `sourceData` and `targetData` arguments to the same tree is also supported.\n * @param childrenField - The field that points to the dataItem sub items. Defaults to `items`.\n * @returns - The updated copies of the `sourceData` and `targetData` input arguments.\n * If `targetData` is not passed, then only the updated copy of the `sourceData` will be returned.\n *\n * @example\n * ```jsx\n * class App extends React.Component {\n *     dragClue;\n *     state = { tree };\n *\n *     render() {\n *         return (\n *             <div>\n *                 <TreeView data={this.state.tree} draggable={true}\n *                     onItemDragOver={this.onItemDragOver} onItemDragEnd={this.onItemDragEnd} />\n *                 <TreeViewDragClue ref={dragClue => this.dragClue = dragClue} />\n *             </div>\n *         );\n *     }\n *\n *     onItemDragOver = (event) => {\n *         this.dragClue.show(event.pageY + 10, event.pageX, event.item.text, this.getClueClassName(event));\n *     }\n *     onItemDragEnd = (event) => {\n *         this.dragClue.hide();\n *         const eventAnalyzer = new TreeViewDragAnalyzer(event).init();\n *\n *         if (eventAnalyzer.isDropAllowed) {\n *             const updatedTree = moveTreeViewItem(\n *                 event.itemHierarchicalIndex,\n *                 this.state.tree,\n *                 eventAnalyzer.getDropOperation(),\n *                 eventAnalyzer.destinationMeta.itemHierarchicalIndex,\n *             );\n *\n *             this.setState({ tree: updatedTree });\n *         }\n *     }\n *     getClueClassName(event) {\n *         const eventAnalyzer = new TreeViewDragAnalyzer(event).init();\n *         const itemIndex = eventAnalyzer.destinationMeta.itemHierarchicalIndex;\n *\n *         if (eventAnalyzer.isDropAllowed) {\n *             switch (eventAnalyzer.getDropOperation()) {\n *                 case 'child':\n *                     return 'k-i-plus';\n *                 case 'before':\n *                     return itemIndex === '0' || itemIndex.endsWith(`${SEPARATOR}0`) ?\n *                         'k-i-insert-up' : 'k-i-insert-middle';\n *                 case 'after':\n *                     const siblings = getSiblings(itemIndex, this.state.tree);\n *                     const lastIndex = Number(itemIndex.split(SEPARATOR).pop());\n *\n *                     return lastIndex < siblings.length - 1 ? 'k-i-insert-middle' : 'k-i-insert-down';\n *                 default:\n *                     break;\n *             }\n *         }\n *\n *         return 'k-i-cancel';\n *     }\n * }\n *\n * function getSiblings(itemIndex, data) {\n *     let result = data;\n *\n *     const indices = itemIndex.split(SEPARATOR).map(index => Number(index));\n *     for (let i = 0; i < indices.length - 1; i++) {\n *         result = result[indices[i]].items;\n *     }\n *\n *     return result;\n * }\n *\n * const SEPARATOR = '_';\n * const tree = [{\n *     text: 'Furniture', expanded: true, items: [\n *         { text: 'Tables & Chairs', expanded: true },\n *         { text: 'Sofas', expanded: true },\n *         { text: 'Occasional Furniture', expanded: true }]\n * }, {\n *     text: 'Decor', expanded: true, items: [\n *         { text: 'Bed Linen', expanded: true },\n *         { text: 'Curtains & Blinds', expanded: true },\n *         { text: 'Carpets', expanded: true }]\n * }];\n *\n * ReactDOM.render(<App />, document.querySelector('my-app'));\n * ```\n */\nexport function moveTreeViewItem(sourceItemHierarchicalIndex, sourceData, operation, targetItemHierarchicalIndex, targetData, childrenField) {\n    var subItemsField = childrenField || CHILDREN_FIELD;\n    if (!validateInput()) {\n        return prepareInputDataForReturn();\n    }\n    var sourceItem = getItemById(sourceItemHierarchicalIndex, sourceData, subItemsField);\n    if (!sourceItem) {\n        return prepareInputDataForReturn();\n    }\n    // The source and the target tree are the same.\n    if (!targetData || targetData === sourceData) {\n        if (!validateNoCircularReference()) {\n            return prepareInputDataForReturn();\n        }\n        var updatedSourceData = removeItem(sourceItemHierarchicalIndex, subItemsField, sourceData);\n        var resultData = addItem(sourceItem, operation, subItemsField, getDecrementedItemIdAfterRemoval(sourceItemHierarchicalIndex, targetItemHierarchicalIndex), updatedSourceData);\n        // A simpler output is explicitly returned when the source and the target tree are\n        // the same, that is, the targetData argument is skipped.\n        return targetData ? { sourceData: resultData, targetData: resultData } : resultData;\n    }\n    else {\n        var updatedSource = removeItem(sourceItemHierarchicalIndex, subItemsField, sourceData);\n        var updatedTarget = addItem(sourceItem, operation, subItemsField, targetItemHierarchicalIndex, targetData);\n        return { sourceData: updatedSource, targetData: updatedTarget };\n    }\n    function prepareInputDataForReturn() {\n        return targetData ? { sourceData: sourceData, targetData: targetData } : sourceData;\n    }\n    function validateNoCircularReference() {\n        return !\"\".concat(targetItemHierarchicalIndex, \"_\").startsWith(\"\".concat(sourceItemHierarchicalIndex, \"_\"));\n    }\n    function validateInput() {\n        if (!sourceData || !sourceData.length ||\n            !sourceItemHierarchicalIndex || !targetItemHierarchicalIndex) {\n            return false;\n        }\n        if (targetData && !targetData.length) {\n            // Dropping over an empty tree is not supported.\n            return false;\n        }\n        // Validate that the target item exists.\n        var data = !targetData || targetData === sourceData ? sourceData : targetData;\n        if (!getItemById(targetItemHierarchicalIndex, data, subItemsField)) {\n            return false;\n        }\n        return true;\n    }\n}\n"],"mappings":"AAAA,SAASA,OAAO,EAAEC,UAAU,QAAQ,mBAAmB;AACvD,SAASC,gCAAgC,EAAEC,WAAW,QAAQ,qBAAqB;AACnF,SAASC,cAAc,QAAQ,gBAAgB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,gBAAgBA,CAACC,2BAA2B,EAAEC,UAAU,EAAEC,SAAS,EAAEC,2BAA2B,EAAEC,UAAU,EAAEC,aAAa,EAAE;EACzI,IAAIC,aAAa,GAAGD,aAAa,IAAIP,cAAc;EACnD,IAAI,CAACS,aAAa,EAAE,EAAE;IAClB,OAAOC,yBAAyB,EAAE;EACtC;EACA,IAAIC,UAAU,GAAGZ,WAAW,CAACG,2BAA2B,EAAEC,UAAU,EAAEK,aAAa,CAAC;EACpF,IAAI,CAACG,UAAU,EAAE;IACb,OAAOD,yBAAyB,EAAE;EACtC;EACA;EACA,IAAI,CAACJ,UAAU,IAAIA,UAAU,KAAKH,UAAU,EAAE;IAC1C,IAAI,CAACS,2BAA2B,EAAE,EAAE;MAChC,OAAOF,yBAAyB,EAAE;IACtC;IACA,IAAIG,iBAAiB,GAAGhB,UAAU,CAACK,2BAA2B,EAAEM,aAAa,EAAEL,UAAU,CAAC;IAC1F,IAAIW,UAAU,GAAGlB,OAAO,CAACe,UAAU,EAAEP,SAAS,EAAEI,aAAa,EAAEV,gCAAgC,CAACI,2BAA2B,EAAEG,2BAA2B,CAAC,EAAEQ,iBAAiB,CAAC;IAC7K;IACA;IACA,OAAOP,UAAU,GAAG;MAAEH,UAAU,EAAEW,UAAU;MAAER,UAAU,EAAEQ;IAAW,CAAC,GAAGA,UAAU;EACvF,CAAC,MACI;IACD,IAAIC,aAAa,GAAGlB,UAAU,CAACK,2BAA2B,EAAEM,aAAa,EAAEL,UAAU,CAAC;IACtF,IAAIa,aAAa,GAAGpB,OAAO,CAACe,UAAU,EAAEP,SAAS,EAAEI,aAAa,EAAEH,2BAA2B,EAAEC,UAAU,CAAC;IAC1G,OAAO;MAAEH,UAAU,EAAEY,aAAa;MAAET,UAAU,EAAEU;IAAc,CAAC;EACnE;EACA,SAASN,yBAAyBA,CAAA,EAAG;IACjC,OAAOJ,UAAU,GAAG;MAAEH,UAAU,EAAEA,UAAU;MAAEG,UAAU,EAAEA;IAAW,CAAC,GAAGH,UAAU;EACvF;EACA,SAASS,2BAA2BA,CAAA,EAAG;IACnC,OAAO,CAAC,EAAE,CAACK,MAAM,CAACZ,2BAA2B,EAAE,GAAG,CAAC,CAACa,UAAU,CAAC,EAAE,CAACD,MAAM,CAACf,2BAA2B,EAAE,GAAG,CAAC,CAAC;EAC/G;EACA,SAASO,aAAaA,CAAA,EAAG;IACrB,IAAI,CAACN,UAAU,IAAI,CAACA,UAAU,CAACgB,MAAM,IACjC,CAACjB,2BAA2B,IAAI,CAACG,2BAA2B,EAAE;MAC9D,OAAO,KAAK;IAChB;IACA,IAAIC,UAAU,IAAI,CAACA,UAAU,CAACa,MAAM,EAAE;MAClC;MACA,OAAO,KAAK;IAChB;IACA;IACA,IAAIC,IAAI,GAAG,CAACd,UAAU,IAAIA,UAAU,KAAKH,UAAU,GAAGA,UAAU,GAAGG,UAAU;IAC7E,IAAI,CAACP,WAAW,CAACM,2BAA2B,EAAEe,IAAI,EAAEZ,aAAa,CAAC,EAAE;MAChE,OAAO,KAAK;IAChB;IACA,OAAO,IAAI;EACf;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}